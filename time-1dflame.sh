#!/bin/bash

set -e
set -x
set -o pipefail

date

TIMING_HOME=$(pwd)
TIMING_HOST=$(hostname)
TIMING_DATE=$(date "+%Y-%m-%d %H:%M")
TIME_SINCE_EPOCH=$(date +%s)
TIMING_PLATFORM=$(uname)
TIMING_ARCH=$(uname -m)
TIMING_REPO="illinois-ceesd/timing.git"
TIMING_BRANCH="flame-timing"

# -- Install conda env, dependencies and MIRGE-Com via *emirge*
# --- remove old run if it exists
if [ -d "emirge" ]
then
    echo "Removing old timing run."
    mv -f emirge emirge.old
    rm -rf emirge.old &
fi
# --- grab emirge and install MIRGE-Com 
git clone https://github.com/illinois-ceesd/emirge.git
cd emirge
./install.sh --env-name=flame1d.timing.env

# -- Activate the env we just created above
export EMIRGE_HOME="${TIMING_HOME}/emirge"
source ${EMIRGE_HOME}/config/activate_env.sh

cd mirgecom

# -- Grab and merge the branch with flame1d-dependent features
git fetch https://github.com/illinois-ceesd/mirgecom.git y1_combustion:y1_combustion
Y1_HASH=$(git rev-parse y1_combustion)
git checkout main
MIRGE_HASH=$(git rev-parse main)
git branch -D temp || true
git switch -c temp
git merge y1_combustion --no-edit

# -- Produce the driver to use for timing
# --- Grab the flame driver repo
rm -Rf CEESD-Y1_Flame1D
git clone https://github.com/anderson2981/CEESD-Y1_Flame1D.git
cd CEESD-Y1_Flame1D/timing_run
DRIVER_HASH=$(git rev-parse main)

# --- DEVELOPERS NOTE:
# --- The following (sed) edit is fragile in that, like a patch, it
# --- depends on the driver having certain code constructs. If the
# --- driver changes significantly, the following sed edit may fail,
# --- and require updating.
# --- In particular, we have taken care that the sed replacement with
# --- the keyword *mode* below only replaces the first instance in the
# --- file. Since this keyword is frequently shared among I/O APIs,
# --- it is possible that new code introduced into the target file,
# --- flame_timing.py, may cause this sed edit to edit the wrong call.
#
# --- Edit the flame driver for:
# ---- 20 steps
# ---- no i/o
# ---- desired file namings
sed -e 's/\(nviz = \).*/\11000/g' \
    -e 's/\(nrestart = \).*/\11000/g' \
    -e 's/\(current_dt = \).*/\15e-8/g' \
    -e 's/\(t_final = \).*/\11e-6/g' \
    -e 's/y0_euler/flame-timing/g' \
    -e 's/y0euler/flame-timing/g' \
    -e 's/mode="wu"/mode="wo"/' \
    -e 's/\(casename = \).*/\1"flame-timing"/g' < ./flame.py > ./flame_timing.py

# --- Get an MD5Sum for the untracked flame_timing driver
DRIVER_MD5SUM="None"
if command -v md5sum &> /dev/null
then 
    DRIVER_MD5SUM=$(md5sum ./flame_timing.py | cut -d " " -f 1)
else
    echo "Warning: No md5sum command found. Skipping  md5sum for untracked driver."
fi

# -- Run the case (platform-dependent)
printf "Running on Host: ${TIMING_HOST}\n"
date
GPU_ARCH="Unknown"
case $TIMING_HOST in

    # --- Run the timing test in a batch job on Lassen@LLC
    lassen*)
        echo "Resolved Host: Lassen"
        TIMING_HOST="Lassen"
        GPU_ARCH="GV100GL"
        rm -f flame_timing_job.sh
        rm -f timing-run-done
        # ---- Generate a batch script for running the timing job
        cat <<EOF > flame_timing_job.sh
#!/bin/bash
#BSUB -nnodes 1
#BSUB -G uiuc
#BSUB -W 30
#BSUB -q pdebug

printf "Running with EMIRGE_HOME=${EMIRGE_HOME}\n"

source "${EMIRGE_HOME}/config/activate_env.sh"
export PYOPENCL_CTX="port:tesla"
export XDG_CACHE_HOME="/tmp/$USER/xdg-scratch"
rm -rf \$XDG_CACHE_HOME
rm -f timing-run-done
jsrun -g 1 -a 1 -n 1 python -O -u -m mpi4py ./flame_timing.py
touch timing-run-done

EOF
        chmod +x flame_timing_job.sh
        # ---- Submit the batch script and wait for the job to finish
        bsub flame_timing_job.sh
        # ---- Wait 10 minutes right off the bat (the job is at least 10 min)
        sleep 600
        iwait=0
        while [ ! -f ./timing-run-done ]; do 
            iwait=$((iwait+1))
            if [ "$iwait" -gt 360 ]; then # give up after 1 hour
                printf "Timed out waiting on batch job.\n"
                exit 1 # skip the rest of the script
            fi
            sleep 10
        done
        ;;

    # --- Run the timing test on an unknown/generic machine 
    *)
        printf "Host: Unknown\n"
        PYOPENCL_TEST=port:pthread python -m mpi4py ./flame_timing.py
        ;;
esac

date

# -- Process the results of the timing run
RUN_LOG_FILE='flame-timing-rank0.sqlite'
if [[ -f "${RUN_LOG_FILE}" ]]; then

    rm -f flame_timings.yaml
    rm -f log.sqlite

    # --- Pull the timings out of the sqlite files generated by logging
    runalyzer-gather log.sqlite ${RUN_LOG_FILE}
    CL_DEVICE=$(sqlite3 log.sqlite 'SELECT cl_device_name FROM runs')
    STARTUP_TIME=$(runalyzer -m log.sqlite -c 'print(q("select $t_init.max").fetchall()[0][0])' | grep -v INFO)
    FIRST_STEP=$(runalyzer -m log.sqlite -c 'print(sum(p[0] for p in q("select $t_step.max").fetchall()[0:1]))' | grep -v INFO)
    FIRST_10_STEPS=$(runalyzer -m log.sqlite -c 'print(sum(p[0] for p in q("select $t_step.max").fetchall()[0:10]))' | grep -v INFO)
    SECOND_10_STEPS=$(runalyzer -m log.sqlite -c 'print(sum(p[0] for p in q("select $t_step.max").fetchall()[11:21]))' | grep -v INFO)

    # --- Create a YAML-compatible text snippet with the timing info
    printf "run_date: ${TIMING_DATE}\nrun_host: ${TIMING_HOST}\n" > flame_timings.yaml
    printf "cl_device: ${CL_DEVICE}\n" >> flame_timings.yaml
    printf "run_epoch: ${TIME_SINCE_EPOCH}\nrun_platform: ${TIMING_PLATFORM}\n" >> flame_timings.yaml
    printf "run_arch: ${TIMING_ARCH}\ngpu_arch: ${GPU_ARCH}\n" >> flame_timings.yaml
    printf "mirge_version: ${MIRGE_HASH}\ny1_version: ${Y1_HASH}\n" >> flame_timings.yaml
    printf "driver_version: ${DRIVER_HASH}\ndriver_md5sum: ${DRIVER_MD5SUM}\n" >> flame_timings.yaml
    printf "time_startup: ${STARTUP_TIME}\ntime_first_step: ${FIRST_STEP}\n" >> flame_timings.yaml
    printf "time_first_10: ${FIRST_10_STEPS}\ntime_second_10: ${SECOND_10_STEPS}\n---\n" >> flame_timings.yaml

    # Users should set special keys for using git over
    # ssh for security concerns. This snippet will use
    # a pre-arranged ssh key if the user provides one
    # and indicates it with the TESTING_SSH_KEY environment
    # variable.
    # ===== To create a key:
    # - Run ssh-keygen:
    # $ ssh-keygen
    # [enter a <keyname> when prompted]
    # - Put the key(s) in a /secure/filesystem/location:
    # $ mv <keyname>* /secure/filesystem/location
    # - Add the key to GIT:
    # $ [browse to] https://github.com/illinois-ceesd/timing/settings/keys/new
    # $ Choose (New SSH key)
    # $ Paste in the contents of /secure/filesystem/location/<keyname>.pub
    # - Set the ENV variable before using this script:
    # $ export TESTING_SSH_KEY=/secure/filesystem/location/<keyname>
    if [ ! -z "${TESTING_SSH_KEY}" ]; then
        eval $(ssh-agent)
        trap "kill $SSH_AGENT_PID" EXIT
        ssh-add ${TESTING_SSH_KEY}
    fi

    # --- Update the timing data in the repo
    # ---- First, clone the timing repo
    git clone -b ${TIMING_BRANCH} git@github.com:${TIMING_REPO}
    # ---- Create the timing file if it does not exist
    if [[ ! -f timing/y1-flame-timings.yaml ]]; then 
        touch timing/y1-flame-timings.yaml
        (cd timing && git add y1-flame-timings.yaml)
    fi
    # ---- Update the timing file with the current test data
    cat flame_timings.yaml >> timing/y1-flame-timings.yaml
    # ---- Commit the new data to the repo
    (cd timing && git commit -am "Automatic commit: ${TIMING_HOST} ${TIMING_DATE}" && git push)
else
    printf "Timing run did not produce the expected sqlite file: ${RUN_LOG_FILE}\n"
    exit 1
fi

date
